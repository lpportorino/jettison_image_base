# jettison_health - Health Pool Data Fetcher

A simple Go CLI tool for fetching health pool data from Redis for Jettison services.

## Purpose

Queries Redis DB 2 for health pool metrics and returns structured JSON output for easy integration with monitoring tools, scripts, and services. Designed to be piped to `jq` or consumed by other services.

## Features

- **Multiple Service/Category Queries**: Fetch data for one or more service:category pairs in a single call
- **JSON Output**: All output (success and errors) in JSON format for easy parsing
- **Exit Codes**: Returns 0 if all data retrieved, 1 if any categories missing or on error
- **Environment Configuration**: Redis connection via environment variables
- **Automatic Deduplication**: Duplicate service:category pairs handled automatically

## Installation

### Build from Source

```bash
git clone https://github.com/yourusername/jettison_health.git
cd jettison_health
go build -o jettison_health .
sudo cp jettison_health /usr/local/bin/
```

### Quick Build

```bash
go build -o jettison_health .
```

## Usage

### Basic Syntax

```bash
jettison_health --config <config.json> <service>:<category> [<service>:<category> ...]
```

### Examples

#### Single Service/Category

```bash
jettison_health --config config.json myapp:api
```

**Output:**
```json
{
  "data": {
    "myapp:api": {
      "beats": 1523,
      "cap": 1000,
      "depletion_rate": 100,
      "init": 1500,
      "replenish_rate": 15,
      "running": 1,
      "exit": 0,
      "health": 856,
      "exists": true
    }
  }
}
```

**Exit Code:** `0`

#### Multiple Services/Categories

```bash
jettison_health --config config.json myapp:api myapp:worker otherapp:processor
```

**Output:**
```json
{
  "data": {
    "myapp:api": {
      "beats": 1523,
      "cap": 1000,
      "depletion_rate": 100,
      "init": 1500,
      "replenish_rate": 15,
      "running": 1,
      "exit": 0,
      "health": 856,
      "exists": true
    },
    "myapp:worker": {
      "beats": 892,
      "cap": 500,
      "depletion_rate": 50,
      "init": 500,
      "replenish_rate": 10,
      "running": 1,
      "exit": 0,
      "health": 432,
      "exists": true
    },
    "otherapp:processor": {
      "exists": false,
      "missing_keys": [
        "beats",
        "cap",
        "depletion_rate",
        "init",
        "replenish_rate",
        "running",
        "exit",
        "health"
      ]
    }
  }
}
```

**Exit Code:** `1` (because otherapp:processor doesn't exist)

#### Missing Service/Category

```bash
jettison_health --config config.json nonexistent:service
```

**Output:**
```json
{
  "data": {
    "nonexistent:service": {
      "exists": false,
      "missing_keys": [
        "beats",
        "cap",
        "depletion_rate",
        "init",
        "replenish_rate",
        "running",
        "exit",
        "health"
      ]
    }
  }
}
```

**Exit Code:** `1`

#### Argument Error

```bash
jettison_health --config config.json invalid-format
```

**Output:**
```json
{
  "error": "Invalid arguments",
  "details": "invalid format 'invalid-format', expected <service>:<category>",
  "args": [
    "invalid-format"
  ]
}
```

**Exit Code:** `1`

#### No Arguments

```bash
jettison_health --config config.json
```

**Output:**
```json
{
  "error": "No arguments provided",
  "details": "Usage: jettison_health --config <config.json> <service>:<category> [<service>:<category> ...]",
  "args": []
}
```

**Exit Code:** `1`

#### Missing Configuration

```bash
jettison_health myapp:api
```

**Output:**
```json
{
  "error": "Configuration required",
  "details": "Usage: jettison_health --config <config.json> <service>:<category> [<service>:<category> ...]",
  "args": ["myapp:api"]
}
```

**Exit Code:** `1`

## Configuration

jettison_health uses a JSON configuration file with ridler-compatible secret management:

```json
{
  "redis": {
    "host": "localhost",
    "port": 6379,
    "secrets_dir": "/run/jon_secrets/vault/redis/health"
  }
}
```

**Note:** Redis DB is hardcoded to `2` (where health pool data is stored)

### Redis Credentials

Instead of hardcoding passwords, jettison_health reads credentials from a directory generated by [jettison_ridler](https://github.com/lpportorino/jettison_ridler):

- **Username**: Inferred from directory basename (e.g., `health` from `/run/jon_secrets/vault/redis/health`)
- **Password**: Read from `<secrets_dir>/password` file

**Example ridler config** (`/etc/ridler/spec.json`):
```json
{
  "version": 1,
  "vault_root": "/run/jon_secrets/vault",
  "items": [
    {
      "name": "health_redis",
      "type": "redis",
      "path": "redis/health",
      "user": "health",
      "length": 32
    }
  ]
}
```

This generates:
```
/run/jon_secrets/vault/redis/health/
├── password  (jettison_health reads this)
└── acl       (Redis server uses this)
```

## Integration with jq

### Extract Health Value

```bash
jettison_health --config config.json myapp:api | jq -r '.data["myapp:api"].health'
# Output: 856
```

### Check if Service Exists

```bash
if jettison_health --config config.json myapp:api | jq -e '.data["myapp:api"].exists'; then
    echo "Service exists"
else
    echo "Service does not exist"
fi
```

### Get Running Status

```bash
jettison_health --config config.json myapp:api | jq -r '.data["myapp:api"].running'
# Output: 1 (running) or 0 (stopped)
```

### Extract Multiple Health Values

```bash
jettison_health --config config.json myapp:api myapp:worker | \
    jq -r '.data | to_entries[] | "\(.key): \(.value.health)"'
# Output:
# myapp:api: 856
# myapp:worker: 432
```

### Filter Only Existing Services

```bash
jettison_health --config config.json myapp:api nonexistent:svc | \
    jq '.data | to_entries | map(select(.value.exists)) | from_entries'
```

### Check Health Status (with thresholds)

```bash
#!/bin/bash
SERVICE="myapp:api"
THRESHOLD=300

HEALTH=$(jettison_health --config config.json "$SERVICE" | jq -r ".data[\"$SERVICE\"].health // 0")

if [ "$HEALTH" -lt "$THRESHOLD" ]; then
    echo "CRITICAL: Health below threshold ($HEALTH < $THRESHOLD)"
    exit 2
else
    echo "OK: Health is $HEALTH"
    exit 0
fi
```

## Output Schema

### Success Response

```json
{
  "data": {
    "<service>:<category>": {
      "beats": <int>,          // Current heartbeat count
      "cap": <int>,            // Maximum health capacity
      "depletion_rate": <int>, // Health loss per second without heartbeats
      "init": <int>,           // Initial health value (can exceed cap for grace period)
      "replenish_rate": <int>, // Health gain per heartbeat
      "running": <int>,        // 0=stopped, 1=running
      "exit": <int>,           // Exit code (0=clean, non-zero=error)
      "health": <int>,         // Current calculated health
      "exists": <bool>,        // true if all keys found
      "missing_keys": [<string>] // Only present if exists=false
    }
  }
}
```

### Error Response

```json
{
  "error": "<string>",    // Error message
  "details": "<string>",  // Detailed error information
  "args": [<string>]      // Arguments that caused the error
}
```

## Exit Codes

- `0` - Success: All requested service:category pairs have complete health data
- `1` - Failure: One or more service:category pairs are missing OR error occurred

## Use Cases

### Monitoring Scripts

```bash
#!/bin/bash
# Check multiple services
jettison_health --config /etc/health/config.json myapp:api myapp:worker | \
    jq -e '.data | to_entries[] | select(.value.exists == false)' && {
    echo "ALERT: Some services have incomplete health data"
    exit 1
}
echo "OK: All services have complete health data"
```

### Dashboard Data Source

```bash
# Fetch data for dashboard
jettison_health --config /etc/health/config.json app1:api app2:processor app3:worker | \
    jq '.data | to_entries | map({
        name: .key,
        health: .value.health,
        status: (if .value.running == 1 then "running" else "stopped" end),
        health_pct: ((.value.health / .value.cap * 100) | floor)
    })'
```

### CI/CD Health Checks

```bash
#!/bin/bash
# Verify service health before deployment
SERVICE="myapp:api"
MIN_HEALTH=500

RESULT=$(jettison_health --config /etc/health/config.json "$SERVICE")
if [ $? -ne 0 ]; then
    echo "ERROR: Cannot fetch health data for $SERVICE"
    exit 1
fi

HEALTH=$(echo "$RESULT" | jq -r ".data[\"$SERVICE\"].health")
if [ "$HEALTH" -lt "$MIN_HEALTH" ]; then
    echo "ERROR: Service health too low ($HEALTH < $MIN_HEALTH). Aborting deployment."
    exit 1
fi

echo "OK: Service health is adequate ($HEALTH >= $MIN_HEALTH). Proceeding with deployment."
```

## Redis Key Format

The tool queries keys in the format:
```
<service>:__healthpool__<category>_<property>
```

Where `<property>` is one of:
- `beats`
- `cap`
- `depletion_rate`
- `init`
- `replenish_rate`
- `running`
- `exit`
- `health`

Example: `myapp:__healthpool__api_health`

## Related Tools

- **HB Server** - Calculates health values and stores them in Redis
- **Wrapp** - Captures application output and stores heartbeat markers
- **heartbeat_util** - C library for generating health pool markers

## Troubleshooting

### Redis Connection Failed

```bash
$ jettison_health --config config.json myapp:api
{
  "error": "Redis connection failed",
  "details": "dial tcp 127.0.0.1:6379: connect: connection refused"
}
```

**Solution:** Check Redis is running and accessible

```bash
redis-cli -n 2 ping

# Verify configuration
cat config.json

# Check secrets are readable
sudo ls -la /run/jon_secrets/vault/redis/health/
sudo cat /run/jon_secrets/vault/redis/health/password
```

### Secrets Not Found

```bash
$ jettison_health --config config.json myapp:api
{
  "error": "Credential loading failed",
  "details": "failed to read password file /run/jon_secrets/vault/redis/health/password: no such file or directory"
}
```

**Solution:** Ensure ridler ran successfully

```bash
# Check ridler service status
sudo systemctl status ridler.service

# Check vault directory exists
ls -la /run/jon_secrets/vault/

# Verify permissions (should be mode 0400, owned by root)
sudo ls -la /run/jon_secrets/vault/redis/health/
```

### Invalid Format

```bash
$ jettison_health --config config.json myapp
{
  "error": "Invalid arguments",
  "details": "invalid format 'myapp', expected <service>:<category>",
  "args": ["myapp"]
}
```

**Solution:** Use correct format `service:category`

### Missing Keys

If a service exists but some keys are missing:

```json
{
  "data": {
    "myapp:api": {
      "beats": 100,
      "cap": 1000,
      "exists": false,
      "missing_keys": ["running", "exit", "health"]
    }
  }
}
```

This indicates incomplete health pool setup. Ensure all required keys are set in Redis.
